#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WIDTH 1600
#define HEIGHT 900
#define WORKGROUP_SIZE 32
layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

layout(push_constant) uniform constants
{
    mat4 transform;
    float time;
} PushConstants;

struct Pixel
{
    vec4 value;
};

layout (binding = 0, rgba8) uniform image2D resultImage;

vec4 cast_ray(vec3 origin, vec3 direction)
{
    vec3 spherepos = vec3(0);
    float sphereradius = 1.0f;

    vec3 pos = origin;
    for (int i = 0; i < 200; i++)
    {
        pos = origin + direction * i * 0.05f;

        vec3 deltapos = spherepos - pos;
        if (length(deltapos) < sphereradius) {
            return vec4(1, 0, 0, 1);
        }

    }

    return vec4(0, 0, 0, 1);
}

void main()
{
    vec3 camerapos = -(PushConstants.transform * vec4(0, 0, 0, 1)).xyz;
    vec3 cameradir = (PushConstants.transform * vec4(0, 0, 1, 0)).xyz;

    // Terminate unnecessary workgroup threads
    if (gl_GlobalInvocationID.x >= WIDTH || gl_GlobalInvocationID.y >= HEIGHT)
    return;

    float x = float(gl_GlobalInvocationID.x) / float(WIDTH);
    float y = float(gl_GlobalInvocationID.y) / float(HEIGHT);

    vec2 uv = vec2(x, y) * 2.0 - 1.0;
    uv.x *= WIDTH / float(HEIGHT);
    vec3 dir = normalize(vec3(uv, 1));

    vec3 worlduv = -(PushConstants.transform * vec4(uv, 0, 1)).xyz;
    vec3 worlddir = (PushConstants.transform * vec4(dir, 0)).xyz;

    vec4 color = cast_ray(worlduv, worlddir);

        imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), color);
    //    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(worlduv, 1));
    //    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(worlddir, 1));
//    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(cameradir, 1));

}